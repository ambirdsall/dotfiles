#+TITLE: Alex Birdsall's doom emacs config

This is my doom config. It's a literate config, so the code snippets are living documentation; they
get exported to specific init files.

At present, this /almost/ only tangles to elisp files for doom emacs to load; it also builds ~/.guile

* file preambles that should come first in the output
** top-of-file comment sections
#+begin_src elisp :tangle packages.el :noweb yes
<<packages-preamble>>
#+end_src

#+begin_src elisp :noweb yes
<<config-preamble>>
#+end_src

* whoami
Some functionality uses this to identify you, e.g. GPG configuration, email clients, file templates and snippets.

#+begin_src elisp
(setq user-full-name "Alex Birdsall"
      user-mail-address "ambirdsall@gmail.com")
#+end_src

* Who configures the configuration?
I do.

[a definitely very cool picture goes here eventually, probably]

#+begin_src elisp
(map! :leader
      :desc "open doom config" "F" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
      :desc "open doom config" "fP" (cmd! (find-file (expand-file-name "config.org" doom-private-dir))))
#+end_src

** what kind of spaceship doesn't come with a spedometer?
#+begin_src elisp :tangle packages.el
(package! benchmark-init)
#+end_src

** a literate config, tangled asynchronously
This is shamelessly lifted from [[https://tecosaur.github.io/emacs-config/config.html][Tecosaur's config]]; since you seem to be the sort of
eccentric who reads emacs configs, odds are good that either you're already familiar with
it or you should be.

#+begin_src emacs-lisp
(defvar +literate-tangle--proc nil)
(defvar +literate-tangle--proc-start-time nil)

(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (unless (getenv "__NOTANGLE")
    (let ((default-directory doom-private-dir))
      (when +literate-tangle--proc
        (message "Killing outdated tangle process...")
        (set-process-sentinel +literate-tangle--proc #'ignore)
        (kill-process +literate-tangle--proc)
        (sit-for 0.3)) ; ensure the message is seen for a bit
      (setq +literate-tangle--proc-start-time (float-time)
            +literate-tangle--proc
            (start-process "tangle-config"
                           (get-buffer-create " *tangle config*")
                           "emacs" "--batch" "--eval"
                           (format "(progn \
(require 'ox) \
(require 'ob-tangle) \
(setq org-confirm-babel-evaluate nil \
      org-inhibit-startup t \
      org-mode-hook nil \
      write-file-functions nil \
      before-save-hook nil \
      after-save-hook nil \
      vc-handled-backends nil \
      org-startup-folded nil \
      org-startup-indented nil) \
(org-babel-tangle-file \"%s\" \"%s\"))"
                                   +literate-config-file
                                   (expand-file-name (concat doom-module-config-file ".el")))))
      (set-process-sentinel +literate-tangle--proc #'+literate-tangle--sentinel)
      (run-at-time nil nil (lambda () (message "Tangling config.org"))) ; ensure shown after a save message
      "Tangling config.org...")))

(defun +literate-tangle--sentinel (process signal)
  (cond
   ((and (eq 'exit (process-status process))
         (= 0 (process-exit-status process)))
    (message "Tangled config.org sucessfully (took %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))
   ((memq (process-status process) (list 'exit 'signal))
    (pop-to-buffer (get-buffer " *tangle config*"))
    (message "Failed to tangle config.org (after %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))))

(defun +literate-tangle-check-finished ()
  (when (and (process-live-p +literate-tangle--proc)
             (yes-or-no-p "Config is currently retangling, would you please wait a few seconds?"))
    (switch-to-buffer " *tangle config*")
    (signal 'quit nil)))
(add-hook! 'kill-emacs-hook #'+literate-tangle-check-finished)
#+end_src
* this config [[https://en.wikipedia.org/wiki/Unitarian_Universalist_Association#Principles_and_purposes][covenants to affirm and promote the inherent worth and dignity]] of every computer it's installed on, even macs
I was raised by and around a bunch of earnest, wordy people; deal with it.

#+begin_src elisp
(setq! mac-command-modifier 'meta
       mac-option-modifier 'meta
       ns-function-modifier 'super)
#+end_src

* appearance
** splash screen
For additional reference, see [[https://discourse.doomemacs.org/t/how-to-change-your-splash-screen/57][this doom discourse post]].

*** make it look nice
I don't rely on the short menu anymore; I know how to get around in doom/emacs just fine now. Let's get rid of that. And while we're at it, let's replace the splash image with something nice:
#+begin_src elisp
(setq fancy-splash-image (concat doom-private-dir "emacs.png"))
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-footer)
#+end_src

*** TODO make it super useful
Hat tip to [[https://tecosaur.github.io/emacs-config/config.html#dashboard-quick-actions][tecosaur's config]], whence much of this came. First off, let's make it easy to
open the dashboard:
#+begin_src elisp :tangle no
(map! :leader :desc "Dashboard" "d" #'+doom-dashboard/open)
#+end_src

Teco adds some additional code to clean
up the appearance of the dashboard; this could use some similar TLC as a follow-up.

*For now, this is disabled (via ~:tangle no~); despite the bindings being tagged with ~:ne~,
they are, in practice, only being added to the emacs-state map.*

#+begin_src elisp :tangle no
(defun +doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Find file" :ne "f" #'find-file
        :desc "Recent files" :ne "r" #'consult-recent-file
        :desc "Config dir" :ne "C" #'doom/open-private-config
        :desc "Open config.org" :ne "c" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
        :desc "Open dotfile" :ne "." (cmd! (doom-project-find-file "~/.config/"))
        :desc "Notes (roam)" :ne "n" #'org-roam-node-find
        :desc "Switch buffer" :ne "b" #'+vertico/switch-workspace-buffer
        :desc "Switch buffers (all)" :ne "B" #'consult-buffer
        :desc "IBuffer" :ne "i" #'ibuffer
        :desc "Previous buffer" :ne "p" #'previous-buffer
        :desc "Set theme" :ne "t" #'consult-theme
        :desc "Quit" :ne "Q" #'save-buffers-kill-terminal
        :desc "Show keybindings" :ne "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))

(add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
#+end_src

** typography
*** fonts
On arch linux, here are the packages you'll want to download:
- =ttf-fira-code=
- =otf-overpass=
- =ttc-iosevka=
- =ttc-iosevka-slab=

Fira Code is
#+begin_src elisp
(setq doom-font-increment 1
      doom-font (font-spec :family "Fira Code" :size (if IS-MAC 13 16) :style "Retina" :weight 'semi-bold)
      ;; doom-font (font-spec :family "Iosevka Fixed Slab" :size 16 :weight 'medium)
      doom-big-font (font-spec :family "Fira Code" :size (if IS-MAC 20 26))
      doom-variable-pitch-font (font-spec :family "Overpass" :size (if IS-MAC 15 20))
      doom-serif-font (font-spec :family "Iosevka Slab" :size (if IS-MAC 13 16))
      doom-unicode-font (font-spec :family "Iosevka" :size (if IS-MAC 13 16)))
#+end_src
We’d like to use mixed pitch in certain modes. If we simply add a hook, when directly
opening a file with (a new) Emacs, ~mixed-pitch-mode~ runs before UI initialisation, which is
problematic. To resolve this, we create a hook that runs after UI initialisation and both
- conditionally enables ~mixed-pitch-mode~
- sets up the mixed pitch hooks
#+begin_src elisp
(defvar mixed-pitch-modes '(org-mode markdown-mode gfm-mode Info-mode text-mode)
  "Modes that `mixed-pitch-mode' should be enabled in, but only after UI initialisation.")
(defun init-mixed-pitch-h ()
  "Hook `mixed-pitch-mode' into each mode in `mixed-pitch-modes'.
Also immediately enables `mixed-pitch-modes' if currently in one of the modes."
  (when (memq major-mode mixed-pitch-modes)
    (mixed-pitch-mode 1))
  (dolist (hook mixed-pitch-modes)
    (add-hook (intern (concat (symbol-name hook) "-hook")) #'mixed-pitch-mode)))
(add-hook 'doom-init-ui-hook #'init-mixed-pitch-h)
#+end_src

Additionally, there are emojis:
#+begin_src elisp :tangle packages.el
(package! emojify)
#+end_src

*** TODO try out [[https://www.reddit.com/r/emacs/comments/shzif1/n%CE%BBno_font_stack/][NANO emacs font stack]]
I mean, it's nice.

*** whitespace
#+begin_src elisp
(whitespace-mode 1)
#+end_src
** theme this bad boy
*** TODO wrap all theme config in a single ~(unless noninteractive <theme config>)~ form and =noweb= in the different logical sections
*** that said...
**** Define a theme switcher utility
Sometimes (usually) I want dark mode; sometimes (presenting, in direct sunlight, or just
mixing it up) I want light mode. What I do /not/ want is to have to pick a specific theme
out of a haystack by name each time I want to toggle between light and dark; give me
instead the blithe simplicity of a lightswitch flipped in passing. Or rather, let me give
it to myself, so I can flit over to a different light and/or dark theme at my pleasure:
#+begin_src elisp
(unless noninteractive
  (setq
   ;; amb/doom-dark-theme 'modus-vivendi
   amb/doom-dark-theme 'doom-badger
   amb/doom-light-theme 'modus-operandi)

  (defun amb/toggle-themes ()
    "Cycle through a set of predefined themes according to whatever unholy logic is currently residing in its inner `cond' form."
    (interactive)
    (cond ((eq doom-theme amb/doom-dark-theme) (load-theme amb/doom-light-theme))
          (t (load-theme amb/doom-dark-theme))))

  (map! :leader
        "tt" #'amb/toggle-themes)

  (load-theme amb/doom-dark-theme t))
#+end_src

***** TODO use a ring instead of imperatively toggling btw hardcoded vars
- [ ] look up rings in elisp manual lol
- [ ] create a container var that is, you guessed it,,,
- [ ] iterate through that in ~amb/toggle-themes~

**** tweak modus themes
The modus themes (included with emacs since version twenty-eight point something) are a
thoughtfully-designed, goal-oriented set of color themes, designed for accessibility and
readability (high-contrast, anti-deuteranopic variants) and sporting delightfully-paired
names:
- /modus operandi/ :: Mode, or manner, of that which is to be worked. The light color theme, for one's toil under the sun.
- /modus vivendi/ :: Mode, or manner, of living. The dark color theme, for one's toil under monitor glare.

Speaking of toggling switches, the modus themes expose quite a few semantically-named
variables for users to tweak; let's do so.

By default, as of writing, ~modus-vivendi~ uses a background color of ~#000000~ and text color
of ~#ffffff~. This pairing provides a /glaring/ degree of contrast; while that's in line with
the stated goals of the themes, let's tone it down just a touch. A touch of blue gives the
background a subtle "night sky" vibe; a touch of red makes the foreground text warmer.
We'll also want a corresponding adjustment to the background color of highlighted (i.e.
current) lines.

#+begin_src elisp
(unless noninteractive
  (require-theme 'modus-themes)

  (setq modus-themes-bold-constructs t
        modus-themes-italic-constructs t
        modus-themes-syntax (list 'alt-syntax 'yellow-comments)
        modus-themes-vivendi-color-overrides
        '((bg-main . "#0d0b11")
          (fg-main . "#ffeeee")
          (bg-hl-line . "#29272f"))
        modus-themes-operandi-color-overrides
        '((bg-hl-line . "#eeeeee"))))
#+end_src

** line numbers
This determines the style of line numbers in effect. If set to ~nil~, line numbers are disabled. For
relative line numbers, set this to ~relative~.
#+begin_src elisp
(setq display-line-numbers-type 'relative)
#+end_src
** long lines: don't do 'em
#+begin_src elisp
(setq! fill-column 90)
(global-visual-line-mode -1)
#+end_src
** Window title
I’d like to have just the buffer name, then if applicable the project folder

#+begin_src elisp
(setq frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
#+end_src


For example when I open my config file it the window will be titled config.org ● doom then as soon as I make a change it will become config.org ◉ doom.
** tab bar :: display workspaces
Taken from [[https://discourse.doomemacs.org/t/permanently-display-workspaces-in-the-tab-bar/4088][hylo's discourse post]], thanks hylo.

Notably, clicking on the tabs accomplishes nothing helpful with this setup.
#+begin_src elisp
(custom-set-faces!
  '(+workspace-tab-face :inherit default :family "Overpass" :height 135)
  '(+workspace-tab-selected-face :inherit (highlight +workspace-tab-face)))

(tab-bar-history-mode)

(after! persp-mode
  (defun workspaces-formatted ()
    ;; fancy version as in screenshot
    (+doom-dashboard--center (frame-width)
                             (let ((names (or persp-names-cache nil))
                                   (current-name (safe-persp-name (get-current-persp))))
                               (mapconcat
                                #'identity
                                (cl-loop for name in names
                                         for i to (length names)
                                         collect
                                         (concat (propertize (format " %d" (1+ i)) 'face
                                                             `(:inherit ,(if (equal current-name name)
                                                                             '+workspace-tab-selected-face
                                                                           '+workspace-tab-face)
                                                               :weight bold))
                                                 (propertize (format " %s " name) 'face
                                                             (if (equal current-name name)
                                                                 '+workspace-tab-selected-face
                                                               '+workspace-tab-face))))
                                " "))))
  (defun amb/invisible-current-workspace ()
    "The tab bar doesn't update when only faces change (i.e. the
current workspace), so we invisibly print the current workspace
name as well to trigger updates"
    (propertize (safe-persp-name (get-current-persp)) 'invisible t))

  (customize-set-variable 'tab-bar-format '(workspaces-formatted tab-bar-format-align-right amb/invisible-current-workspace))

  ;; don't show current workspaces when we switch, since we always see them
  (advice-add #'+workspace/display :override #'ignore)
  ;; same for renaming and deleting (and saving, but oh well)
  (advice-add #'+workspace-message :override #'ignore))

;; need to run this later for it to not break frame size for some reason
(run-at-time nil nil (cmd! (tab-bar-mode +1)))
#+end_src

Having made this nice tab bar, we need a way to toggle it: some modes (notably PDFView)
have rendering logic that doesn't play nicely with (or is not properly aware of) the tab
bar.

#+begin_src elisp
(map! :leader
      :desc "toggle tab bar" "tT" #'tab-bar-mode)
#+end_src

*** TODO Mouse click bindings for the tab bar
A normal click on a tab navigates to it (optionally, if not the current one). Right clicking brings up a menu of nice things to be able to do.

*** TODO PDFView mode does not take tab bar height into account when rendering a page
The end result is having to scroll a small amount whenever I (\*Bob Seger voice*) turn the
page, which is frankly a bit annoying. A shitty workaround is to manually toggle, I guess.
* odds and ends
** text manipulation utilities
*** TODO helper macros (which should be tidied off to an appendix with noweb)
Working with text combines a huge variety of content-specific considerations with a very
narrow, consistent API; there are a lot of repetitive definitions. Let's improve that:
#+begin_src elisp
(defmacro cmds--on-string-or-region (fn)
  "Given a string-manipulation function FN, defines an interactive command which will apply that
function to either a string argument or to selected text, depending on context."
  `(lambda (string &optional from to)
     (interactive
      (if (use-region-p)
          (list nil (region-beginning) (region-end))
        (let ((bds (bounds-of-thing-at-point 'paragraph)))
          (list nil (car bds) (cdr bds)))))

     (let* ((work-on-string? (if string t nil))
            (input-str (if work-on-string?
                           string
                         (buffer-substring-no-properties from to)))
            (output-str (funcall ,fn input-str)))

       (if work-on-string?
           output-str
         (save-excursion
           (delete-region from to)
           (goto-char from)
           (insert output-str))))))

;; TODO use defalias instead of fset so docstrings can be set
(defmacro def-text-transform (name fn)
  "Create a new interactive command bound to NAME using some
string manipulation function FN. It will work given a string
argument programmatically or by operating on selected text when
used interactively."
  `(fset ,name (cmds--on-string-or-region ,fn)))
#+end_src

*** ~(not-every programming_language({conventionallyUses: "THE_SAME_CASING"}))~
Let's make some helper commands for manipulating the casing of programming symbols. Since
they are defined with ~def-text-transform~, they're usable as elisp string utilities and as
a command on region both.
#+begin_src elisp
(def-text-transform 'kebab-case #'s-dashed-words)
(def-text-transform 'pascal-case #'s-upper-camel-case)
(def-text-transform 'camel-case #'s-lower-camel-case)
(def-text-transform 'snake-case #'s-snake-case)
(def-text-transform 'screaming-snake-case #'(lambda (str) (s-upcase (s-snake-case str))))
(def-text-transform 'lower-words-case #'(lambda (str) (s-join " " (-map #'s-downcase (s-split-words str)))))
#+end_src

*** manipulate numbers at point
#+begin_src elisp
(defun decrement-number-at-point ()
  "Decrement the number at point by 1."
  (interactive)
  (save-excursion
    (skip-chars-backward "0-9")
    (when (looking-at "[0-9]+")
      (let ((num (string-to-number (match-string 0))))
        (replace-match (number-to-string (1- num)))))))

(defun increment-number-at-point ()
  "Increment the number at point by 1."
  (interactive)
  (save-excursion
    (skip-chars-backward "0-9")
    (when (looking-at "[0-9]+")
      (let ((num (string-to-number (match-string 0))))
        (replace-match (number-to-string (1+ num)))))))

(map! :leader
      :desc "decrement at point" "nj" #'decrement-number-at-point
      :desc "increment at point" "nk" #'increment-number-at-point)
#+end_src
** clipboard
#+begin_src elisp
(setq! select-enable-clipboard nil)
(map! "C-M-y" #'clipboard-yank)
#+end_src

** TODO uncategorized keybindings :: clean up
#+begin_src elisp
(map!
 :leader
 :desc "prior buffer" "=" #'evil-switch-to-windows-last-buffer
 "Nr" #'narrow-to-region
 "Nf" #'narrow-to-defun
 "Np" #'narrow-to-page
 "Ns" #'org-toggle-narrow-to-subtree
 "Nw" #'widen
 :desc "jump to first non-blank" "of" #'evil-first-non-blank
 :desc "new frame" "oF" #'make-frame
 :desc "Open project TODOs.org file" "po" #'amb/goto-project-todos
 "W" #'subword-mode)

(map!
 "C-;" #'evil-avy-goto-char-timer
 :ni "C-)" #'sp-forward-slurp-sexp
 :ni "C-(" #'sp-backward-slurp-sexp
 :n "M-/" #'+default/search-buffer
 (:when (not (display-graphic-p)) :map (evil-insert-state-map evil-motion-state-map) "C-z" #'suspend-frame))
#+end_src

** copy filename relative to buffer
#+begin_src elisp
(after! projectile
  (defun yank-buffer-filename-relative-to-project ()
    "Copy the current buffer's path, relative to the project root, to the kill ring."
    (interactive)
    (if-let (filename (or buffer-file-name (bound-and-true-p list-buffers-directory)))
        (message (kill-new (f-relative filename (projectile-acquire-root))))
      (error "Couldn't find filename in current buffer"))))

(map! :leader "fY" #'yank-buffer-filename-relative-to-project)
#+end_src

** scratch buffers
#+begin_src elisp
(setq! doom-scratch-initial-major-mode 'org-mode)
#+end_src

** don't automatically open a new workspace for each new emacsclient frame
I like freely opening client instances in the terminal and i3 alike.
#+begin_src elisp
(after! persp-mode (setq! persp-emacsclient-init-frame-behaviour-override -1))
#+end_src
** jump to arbitrary files in specific projects/directories from anywhere
#+begin_src elisp
(after! projectile
  (defmacro file-jumper-for-project (project-root)
    "Defines an anonymous interactive function for picking an arbitrary file from the given PROJECT-ROOT.

Conveniently, by explicitly providing the project root, you can use the conveniently
flattened file hierarchy generated by `projectile-project-files' regardless of whether
projectile would recognize your root directory as a project."
    `(cmd! (find-file (string-join
                       (list
                        ,project-root
                        (projectile-completing-read "Find file: " (projectile-project-files ,project-root)))
                       "/"))))

  (map! :leader
        :desc "Browse dotfiles" "f." (cmd! (find-file
                                         (completing-read "Open dotfile: "
                                                          (split-string (shell-command-to-string "dots ls-files ~") "\n"))))
        :desc "Take me $HOME, country roads" "f~" (cmd! (+vertico/find-file-in "~/"))
        :prefix ("fj" . "Jump into specific projects")
        :desc "Browse ~/.config/" :ne "c" (file-jumper-for-project "~/.config/")
        :desc "Browse ~/bin/" :ne "b" (file-jumper-for-project "~/bin/")))
#+end_src

* programming
** Indent however you wish, as long as you do it right
#+begin_src elisp
(setq standard-indent 2)
#+end_src

** projectile
#+begin_src elisp
(setq! projectile-project-search-path '("~/c/"))
#+end_src
** code compass
#+begin_src elisp :tangle packages.el
(package! code-compass
  :recipe (:host github :repo "ag91/code-compass" :files (:defaults "pages" "scripts")))
#+end_src

#+begin_src elisp
(use-package! code-compass :defer t
              :commands (c/show-hotspots-sync
                         c/show-hotspot-snapshot-sync
                         c/show-code-churn-sync
                         c/show-coupling-graph-sync
                         c/show-code-communication-sync
                         c/show-knowledge-graph-sync
                         c/show-code-age-sync
                         c/show-fragmentation-sync
                         c/show-hotspot-cluster-sync)
              :config
              (setq c/exclude-directories (list "node_modules" "bower_components" "vendor" "tmp" "images"))
              (if IS-MAC (setq c/preferred-browser "open")))
#+end_src
** tree sitter
#+begin_src elisp
(setq treesit-language-source-alist
   '((bash "https://github.com/tree-sitter/tree-sitter-bash")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (css "https://github.com/tree-sitter/tree-sitter-css")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (go "https://github.com/tree-sitter/tree-sitter-go")
     (html "https://github.com/tree-sitter/tree-sitter-html")
     (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (toml "https://github.com/tree-sitter/tree-sitter-toml")
     (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
     (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
     (yaml "https://github.com/ikatyang/tree-sitter-yaml")))
#+end_src

here's a snippet to install you some language libraries
#+begin_src elisp :tangle no
(mapc #'treesit-install-language-grammar
      (mapcar #'car treesit-language-source-alist))
#+end_src

** there are more languages under the sun than ~:lang~ can speak
*** fennel
#+begin_src elisp :tangle packages.el
(package! fennel-mode)
#+end_src

#+begin_src elisp
(use-package! fennel-mode
  :config (add-to-list 'auto-mode-alist '("\\.fnl\\'" . fennel-mode)))
#+end_src
*** graphql
#+begin_src elisp :tangle packages.el
(package! graphql-mode)
#+end_src

#+begin_src elisp
(use-package! graphql-mode)
#+end_src
*** elixir
#+begin_src elisp
(after! alchemist-mode
  (map! (:when (modulep! :lang elixir)    ; local conditional
        (:map alchemist-mode-map
         :n
         "C-j" #'tmux-navigate-down
         "C-k" #'tmux-navigate-up
         :localleader
         "tt" #'exunit-toggle-file-and-test
         "tT" #'exunit-toggle-file-and-test-other-window))))

#+end_src
*** yuck
#+begin_src elisp :tangle packages.el
(package! yuck-mode)
#+end_src
*** the four most frustrating words in the english language: web development in emacs
First two sections largely +yoinked from+ courtesy of https://codeberg.org/ckruse/doom.d/src/commit/c6c7163e79a0fecdda6df9e81e60dc246170213a/config.el
**** {t,j}s
#+begin_src elisp :tangle (and "packages.el" "no")
(package! tsi :recipe (:type git :host github :repo "orzechowskid/tsi.el"))
(package! tsx-mode :recipe (:type git :host github :repo "orzechowskid/tsx-mode.el"))
#+end_src

#+begin_src elisp :tangle no
(setq typescript-indent-level 2
      js-indent-level 2)

(use-package! tsx-mode
  :mode (("\\.tsx\\'" . tsx-mode))
  :hook (tsx-mode . lsp!)
  :hook (tsx-mode . rainbow-delimiters-mode)
  :hook (tsx-mode . add-node-modules-path)
  :custom (tsx-mode-tsx-auto-tags  t)
  :defer t
  :init
  (after! flycheck
    (flycheck-add-mode 'javascript-eslint 'tsx-mode))

  (add-hook! 'tsx-mode-hook
    (defun ck/tsx-setup ()
      (flycheck-select-checker 'javascript-eslint)
      (flycheck-add-next-checker 'javascript-eslint 'lsp)
      (pushnew! flycheck-disabled-checkers
                'javascript-jshint
                'tsx-tide
                'jsx-tide)))

  (set-electric! 'tsx-mode
    :chars '(?\} ?\))
    :words '("||" "&&")))
#+end_src

**** prettier et al with apheleia (until elken's module drops lol)
#+begin_src elisp :tangle packages.el
(package! apheleia)
  #+end_src

#+begin_src elisp
(use-package! apheleia
  :hook ((tsx-mode . apheleia-mode)
         (typescript-mode . apheleia-mode)
         (typescript-tsx-mode . apheleia-mode)
         (js-mode . apheleia-mode)
         (json-mode . apheleia-mode)
         (css-mode . apheleia-mode)
         (scss-mode . apheleia-mode))
  :defer t
  :config
  (push '(tsx-mode . prettier) apheleia-mode-alist)
  (push '(scss-mode . prettier) apheleia-mode-alist)
  (push '(css-mode . prettier) apheleia-mode-alist))
  #+end_src

**** web-mode
#+begin_src elisp
(setq! web-mode-markup-indent-offset 2
       web-mode-css-indent-offset 2
       web-mode-code-indent-offset 2)

(setq! web-mode-engines-alist
      '(("angular" . "\\.html")
        ("vue" . "\\.vue")
        ("phoenix" . "\\.html\\.eex")
        ("erb" . "\\.html\\.erb")))
#+end_src

**** TODO vue
Meanwhile, this little sucker is just _sitting_ in =custom.el=, hideous. This must be improved.
#+begin_quote
 '(auto-insert-alist
   '((("\\.vue\\'" . "Vue component")
      .
      ["template.vue" web-mode autoinsert-yas-expand])))
#+end_quote

**** tailwindcss
#+begin_src elisp :tangle packages.el
(package! lsp-tailwindcss :recipe (:host github :repo "merrickluo/lsp-tailwindcss"))
#+end_src

#+begin_src elisp
(use-package! lsp-tailwindcss
  :after lsp)
#+end_src
*** scheme, or: you've got gall, you've got guile
Apologies to racket, which is a nicer language per se, but guile's already got its grubby
little +mitts+ C ABI in lots of interesting parts of the linux ecosystem and I just don't
have time to shop around. If the list stored at ~geiser-active-implementations~ has length >
1, then every time I restart emacs, I'll be prompted to choose which implementation to
associate with every. single. scheme. buffer. that. I. have. ever. opened. in. my. life.
It gets old fast:
#+begin_src elisp
(setq! geiser-active-implementations '(guile))
#+end_src

Guile's shebang convention is surprisingly well-considered from first principles, in terms
of how it relates to the rest of the language syntax and being a good cross-platform
citizen. It's also weird, complex, and idiosyncratic, and I am apparently incapable of
remembering it.

#+begin_src elisp
(defun insert-guile-shebang ()
  (interactive)
  (save-excursion
   (beginning-of-buffer)
   (insert "#!/usr/local/bin/guile \\
-e main -s
!#

")))
#+end_src

**** pimp my +ride+ .guile
This is my guile repl config. Let's frontload the potentially confusing bit: I would like to rely on the [[https://gitlab.com/NalaGinrut/guile-colorized][guile-colorized]] library, which
is
a) a lovely little quality-of-life improvement, and
b) not packaged with the language

This adds up to a bit of a hassle if one's aim is a config which can be dropped into
different computers and operating systems. My path through the thicket (as of now) is to
add an elisp snippet which shells out to guile to check whether the ~(ice-9 colorized)~
module can be found in the load path; this lets me conditionally tangle the appropriate
version of =~/.guile= accordingly.

Most config is defined outside the conditional top-level src blocks in noweb cookies to
keep things DRY and maintainable.

***** augment load path
#+name: guile-augment-load-path
#+begin_src guile :tangle no
(add-to-load-path (string-append (getenv "HOME") "/lib/scheme"))
#+end_src

***** shared modules
The first line here has ugly indentation so the corresponding noweb cookie (or whatever
the term is) in the source blocks that actually get tangled to =.guile= files can have
pretty indentation.
#+name: guile-shared-modules
#+begin_src guile :tangle no
 (oop goops)
 (srfi srfi-1)
 (srfi srfi-26) ;; cut
 (ice-9 match)
 (ice-9 readline)
#+end_src

***** setup repl
#+name: guile-setup-repl
#+begin_src guile :tangle no
(activate-readline)
#+end_src

***** conditional file templates
#+begin_src guile :noweb yes :tangle (if (string-equal "exists" (shell-command-to-string "test -e `guile -c \"(display (string-append (car %load-path) \\\"/ice-9/colorized.scm\\\"))\"` && echo -n exists")) "~/.guile" "no")
<<guile-augment-load-path>>

(use-modules
 <<guile-shared-modules>>
 (ice-9 colorized))

 <guile-setup-repl>>
(activate-colorized)
#+end_src

But installing a special guile lib and running its (rather manual) installation
process is annoying; until I properly automate it in [[file:~/Makefile][my dotfiles' Makefile]], a
hideously copy-pasted near-duplicate will have to do.
#+begin_src guile :noweb yes :tangle (if (not (string-equal "exists" (shell-command-to-string "test -e `guile -c \"(display (string-append (car %load-path) \\\"/ice-9/colorized.scm\\\"))\"` && echo -n exists"))) "~/.guile" "no")
<<guile-augment-load-path>>

(use-modules
 <<guile-shared-modules>>)

<<guile-setup-repl>>
#+end_src
*** yaml
#+begin_src elisp :tangle packages.el
(package! yaml-pro)
#+end_src

#+begin_src elisp
(use-package! yaml-pro
  :config (add-to-list 'auto-mode-alist '("\\.ya?ml'" . yaml-pro-ts-mode)))
#+end_src
* "I hear lisp is good for AI"
** copilot
#+begin_src elisp :tangle packages.el
(package! copilot
  :recipe (:host github :repo "zerolfx/copilot.el" :files ("*.el" "dist")))
#+end_src

#+begin_src elisp
;; accept completion from copilot and fallback to company
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion-by-word)
              ("TAB" . 'copilot-accept-completion-by-word)
              ("C-TAB" . 'copilot-accept-completion)
              ("C-<tab>" . 'copilot-accept-completion)))
#+end_src
** chatGPT
#+begin_src elisp :tangle packages.el
(package! gptel)
#+end_src

#+begin_src elisp
(use-package! gptel)
#+end_src

* {ma,}git
With apologies to vc-mode, magit is the gold standard. So:
#+begin_src elisp :noweb yes
(after! magit
  <<magit-window-management>>

  <<magit-auto-dash>>

  <<magit-sections>>)
#+end_src

** nice git conflic resolution hydra
Gold standard, yes, but not be all and end all. This defines a nice hydra for working with
files containing git conflicts.

#+begin_src elisp
;; all thanks and apologies to https://github.com/alphapapa/unpackaged.el
(use-package! smerge-mode
  :after (hydra magit)
  :config
  (defhydra unpackaged/smerge-hydra
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("ZZ" (lambda ()
            (interactive)
            (save-buffer)
            (bury-buffer))
     "Save and bury buffer" :color blue)
    ("q" nil "cancel" :color blue))
  :hook (magit-diff-visit-file . (lambda ()
                                   (when smerge-mode
                                     (unpackaged/smerge-hydra/body)))))
#+end_src

** magit status, like the cat in the hat, should clean up after itself
#+name: magit-window-management
#+begin_src elisp
  ;; strictly speaking unnecessary (it's the default)
  ;; (add-hook 'magit-pre-display-buffer-hook #'magit-save-window-configuration)
  (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
  (setq magit-bury-buffer-function #'magit-restore-window-configuration)
#+end_src

** If I can't type a space, why let me?
In scenarios like branch names, whitespace is disallowed. But using the spacebar as a word
separator is deep, deep muscle memory. Why fight it?
#+name: magit-auto-dash
#+begin_src elisp
  (defun just-use-a-dash-instead-sheesh (_nope &rest _dontcare)
    (interactive)
    (self-insert-command 1 ?-))

  (advice-add 'magit-whitespace-disallowed :around #'just-use-a-dash-instead-sheesh)
#+end_src

** magit-status sections
#+name: magit-sections
#+begin_src elisp
(setq! magit-section-initial-visibility-alist '((stashes . show) (commits . show)))
#+end_src
** dotfiles
I manage my dotfiles with a bare git repository; this takes a little extra effort to set
up properly. With a hat tip to [[https://github.com/hylophile/.files/blob/d2d41871bd6a74e4b55fadf44d46613d0bcacb53/.config/doom/config.org#dotfiles][hylo]], from whom much of this is adapted.

The song-and-dance is a two-step:
1) open ~magit-status~ for ~~/~ if no orthodox git repo can be found
2) advise ~magit-process-environment~ to set up the correct, unmatched values for ~GIT_WORK_TREE~ and ~GIT_DIR~ if and only if we're getting the status for the ~~/~ repo.

#+begin_src elisp
(defun amb/magit-status-with-dotfiles-fallback ()
  (interactive)
  (if (magit-gitdir)
      (magit-status)
    (magit-status "~/")))

(map! :after magit :leader "g g" #'amb/magit-status-with-dotfiles-fallback)

;; from https://github.com/magit/magit/issues/460

(defun amb/magit-process-environment (env)
  "Add GIT_DIR and GIT_WORK_TREE to ENV when in a special directory."
  (let ((here (file-name-as-directory (expand-file-name default-directory)))
        (home (expand-file-name "~/")))
    (when (string= here home)
      (let ((gitdir (expand-file-name "~/.dots/")))
        (push (format "GIT_WORK_TREE=%s" home) env)
        (push (format "GIT_DIR=%s" gitdir) env))))
  env)

(advice-add 'magit-process-environment
            :filter-return #'amb/magit-process-environment)
#+end_src

This works for almost everything, but there's not yet a good way to stage new files in the
dotfiles repo. So:
#+begin_src elisp
(defun amb/magit-stage-file ()
  (interactive)
  (if (magit-gitdir)
      (call-interactively #'magit-stage-file)
      (shell-command (concat
                      "git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME add "
                      (buffer-file-name))
                     t)))

(map! :after magit :leader "g S" #'amb/magit-stage-file)
#+end_src

I also have to hide my dotfiles away from projectile to avoid caching /way/ too many files
in ~~/~ (until magit can handle separate work trees) properly: Doom recognizes my home
directory as a git dir, but it doesn't find any of its config whatsoever, which can cause
projectile to act silly when it can't find an intermediate project root (either because of
error or because I used the wrong muscle memory).

#+begin_src elisp :tangle no
(after! projectile (setq projectile-project-root-files-bottom-up (remove ".git"
projectile-project-root-files-bottom-up)))

(defun amb/projectile-find-file ()
  (interactive)
  (if (equal (expand-file-name "~/") (projectile-project-root))
    (call-interactively #'find-file)
    (projectile-find-file)))

(map! :leader "SPC" #'amb/projectile-find-file)
#+end_src
* an opinionated mix of vim and emacs
** wait, is this split two tmux panes or two emacs windows?
WHO CARES
#+begin_src elisp :tangle packages.el
(package! evil-tmux-navigator
  :recipe (:host github :repo "ambirdsall/evil-tmux-navigator"))
(unpin! evil-tmux-navigator)
#+end_src

#+begin_src elisp
(use-package! evil-tmux-navigator
  :config (evil-tmux-navigator-bind-keys))
#+end_src

** replace with register
#+begin_src elisp :tangle packages.el
(package! evil-replace-with-register)
#+end_src

#+begin_src elisp
(use-package! evil-replace-with-register
  :init (setq evil-replace-with-register-key (kbd "gr"))
  :config (evil-replace-with-register-install))
#+end_src
** evil-exchange
#+begin_src elisp :tangle packages.el
(package! evil-exchange)
#+end_src

#+begin_src elisp
(use-package! evil-exchange
  :config (evil-exchange-install))
#+end_src
** matchit
#+begin_src elisp :tangle packages.el
(package! evil-matchit)
#+end_src

#+begin_src elisp
(use-package! evil-matchit
  :config (global-evil-matchit-mode 1))
#+end_src
** line text object
#+begin_src elisp :tangle packages.el
(package! evil-textobj-line
  :recipe (:host github :repo "emacsorphanage/evil-textobj-line"))
#+end_src

#+begin_src elisp
(use-package! evil-textobj-line
  :after evil)
#+end_src
** changing up some default settings
#+begin_src elisp
(setq! evil-ex-search-persistent-highlight nil
       +evil-want-o/O-to-continue-comments nil)
#+end_src

You can have my ~evil-substitute~ when you pry it from my cold, dead fingers.
#+begin_src elisp :tangle packages.el
(package! evil-snipe :disable t)
#+end_src

** imenu
I much prefer evil's indentation command set, making the default ~M-i~ binding,
~tab-to-tab-stop~, a rather poor use of prime real estate. I would be much better served
using it as a mnemonic binding for ~imenu~:
#+begin_src elisp
(map! :after consult "M-i" #'consult-imenu)
#+end_src

** TODO jump into/around a visual selection
=SPC v= is (or was, at time of writing) not a default binding in [[file:~/.emacs.d/modules/config/default/+evil-bindings.el][doom's default evil bindings]]; that seems like a potential oversight.

- If region is not active, works like vim's =gv=
- else, DWIM selection changes
  + cycle through structural selectors?
    - if tree mode is available?
  + that "expand visual selection" package
  + ?

* org-mode config
Notes must be at hand to be helpful, ideally on any of several computers:
#+begin_src elisp
(let ((dir "~/Dropbox/org/"))
  (and (file-exists-p dir)
       (setq org-directory dir)))
#+end_src

With that out of the way, a grab-bag of tweaks and variables.
#+begin_src elisp
(setq! org-log-into-drawer t
       org-hierarchical-todo-statistics nil
       org-refile-use-outline-path 'full-file-path
       org-todo-keywords '((sequence "NEXT(n)" "TODO(t)" "BLOCKED(b)" "SOMEDAY(s)" "PROJ(p)" "QUESTION(q)" "|" "DONE(d)" "CANCELLED(c)")))

(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))

(setq!
 org-hide-emphasis-markers t
 org-agenda-filter-preset '("-quotidian"))

(add-hook! (org-mode) (org-appear-mode 1))
#+end_src

** roam
First, I need a roam directory to serve as the "slipbox":
#+begin_src elisp
(setq org-roam-directory "~/Dropbox/roam/")
#+end_src

I'd like a pretty and interactive graph visualization, too, while I'm at it:
#+begin_src elisp
(use-package! websocket
    :after org-roam)

(use-package! org-roam-ui
    :after org-roam ;; or :after org
;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
;;         a hookable mode anymore, you're advised to pick something yourself
;;         if you don't care about startup time, use
;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src

Org-roam-ui tries to keep up with the latest features of org-roam, which conflicts with Doom Emacs's desire for stability. To make sure nothing breaks, use the latest version of org-roam by unpinning it:
#+begin_src elisp :tangle packages.el
(unpin! org-roam)
(package! org-roam-ui)
#+end_src

** every project has a =todo.org= and every =todo.org= can just be hardlinks of the same underlying file
This pair of variables is required to let you open the same hardlinked todo.org inode in multiple
project-specific locations in the filesystem, and have each maintain its local context (e.g. when
running projectile functions acting on what filesystem heuristics see as the surrounding VC
project). It's an idiosyncratic pattern, but it works brilliantly for me on work computers.

#+begin_src elisp
(setq! find-file-existing-other-name nil
       find-file-visit-truename nil)

(after! projectile
  (defun amb/goto-project-todos ()
    (interactive)
    ;; TODO dynamically create one if missing? This system can be improved further.
    (find-file (concat (projectile-project-root) "todo.org"))))
#+end_src

** the yet-neglected agenda view
These values can be dynamically constructed by concatenating the values of
~org-roam-directory~ and ~org-roam-dailies-directory~; I did try to use those to make this
more future-proof, but that just passed along the unresolved symbol names (I assume
because ~setq~ is a macro) and everything went to heck.
#+begin_src elisp
(setq! org-agenda-files '("~/Dropbox/org/"
                          "~/Dropbox/roam/daily/"))

(defun org-my-auto-exclude-fn (tag)
  (if (cond
       ;; TODO show only the next 2
       ((string= tag "quotidian")
        t)
       ;; only see work things between 8am and 7pm
       ((string= tag "work")
        (let ((hr (nth 2 (decode-time))))
          (or (< hr 8) (> hr 19)))))
      (concat "-" tag)))

(setq org-agenda-auto-exclude-function 'org-my-auto-exclude-fn)

#+end_src

** keybinding fixes
#+begin_src elisp
(map! :after org
 :map 'org-mode-map
      "<tab>" 'org-cycle)
#+end_src

** outlines ✨ everywhere ✨with outshine
#+begin_src elisp :tangle packages.el
(package! outshine
  :recipe (:host github :repo "alphapapa/outshine"))
#+end_src

#+begin_src elisp
(use-package! outshine
  :after org
  :config
  (add-hook 'prog-mode-hook 'outshine-mode))
#+end_src
** 📉_(ツ)_📈
#+begin_src elisp :tangle packages.el
(package! graphviz-dot-mode)
#+end_src

#+begin_src elisp
(use-package! graphviz-dot-mode
  :after org)
#+end_src
** export backends
#+begin_src elisp :tangle packages.el
(package! ox-gfm)
#+end_src

#+begin_src elisp
;; TODO: figure out doom's org exporter API
;; (after! org
;;   '(require 'ox-gfm nil t))
(use-package! ox-gfm
  :after org)

#+end_src

* The secrets I keep with myself, or: praise the Lord and pass the =.gitignore=
This snippet loads a computer-specific config file if it's present. It goes
last, giving me a convenient place for ad hoc overrides of any setting in here.
#+begin_src elisp
(defvar amb/computer-specific-config (expand-file-name "local.el" doom-private-dir)
  "A file for computer-specific config, hidden from git; for
example, configuration for a work computer and its (possibly
private) product projects.")

(let ((amb/computer-specific-config (concat doom-private-dir "local.el")))
  (and (file-exists-p amb/computer-specific-config) (load amb/computer-specific-config)))

(map! :leader
      :desc "open computer-specific doom config" "fL" (cmd! (find-file amb/computer-specific-config)))
#+end_src
* random bugfixes and whatnot
** magit/with-editor/transient-base-map snafu
used to go to ~packages.el~; currently seems to be working, but as of <2023-07-15 Sat>,
there's a bit more testing required before I'm ready to delete this.
#+begin_src elisp :tangle no
(package! transient :pin "c2bdf7e12c530eb85476d3aef317eb2941ab9440")
(package! with-editor :pin "391e76a256aeec6b9e4cbd733088f30c677d965b")
#+end_src

* appendices
** top-of-file preambles
*** packages.el
#+name: packages-preamble
#+begin_src elisp :tangle no
;; -*- no-byte-compile: t; -*-

#+end_src

*** config.el
#+name: config-preamble
#+begin_src elisp :tangle no
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

#+end_src
** undoing bad defaults
I said what I said.
#+begin_src elisp
(setq confirm-kill-emacs nil)
#+end_src
